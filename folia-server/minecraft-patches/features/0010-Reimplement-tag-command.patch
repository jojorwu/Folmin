--- a/net/minecraft/commands/Commands.java
+++ b/net/minecraft/commands/Commands.java
@@ -252,7 +252,7 @@
         AdvancementCommands.register(this.dispatcher);
-        //TagCommand.register(this.dispatcher); // Folia - region threading - TODO later
+        TagCommand.register(this.dispatcher); // Folia - region threading - TODO later
         ExecuteCommand.register(this.dispatcher, this.context);
--- a/net/minecraft/commands/TagCommand.java
+++ b/net/minecraft/commands/TagCommand.java
@@ -0,0 +1,182 @@
+package net.minecraft.commands;
+
+import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.arguments.StringArgumentType;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import java.util.Collection;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicInteger;
+import net.minecraft.commands.arguments.EntityArgument;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.ComponentUtils;
+import net.minecraft.world.entity.Entity;
+import org.bukkit.plugin.Plugin;
+
+public class TagCommand {
+
+    private static Plugin getMinecraftPlugin(CommandSourceStack source) {
+        // Folia: Use the server's plugin instance for scheduling NMS commands.
+        return source.getServer().getMinecraftPlugin();
+    }
+
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        dispatcher.register(Commands.literal("tag")
+            .requires((source) -> source.hasPermission(2))
+            .then(Commands.argument("targets", EntityArgument.entities())
+                .then(Commands.literal("add")
+                    .then(Commands.argument("name", StringArgumentType.word())
+                        .executes((context) -> addTag(
+                                context.getSource(),
+                                EntityArgument.getEntities(context, "targets"),
+                                StringArgumentType.getString(context, "name")
+                            )
+                        )
+                    )
+                )
+                .then(Commands.literal("remove")
+                    .then(Commands.argument("name", StringArgumentType.word())
+                        .executes((context) -> removeTag(
+                                context.getSource(),
+                                EntityArgument.getEntities(context, "targets"),
+                                StringArgumentType.getString(context, "name")
+                            )
+                        )
+                    )
+                )
+                .then(Commands.literal("list")
+                    .executes((context) -> listTags(
+                            context.getSource(),
+                            EntityArgument.getEntities(context, "targets")
+                        )
+                    )
+                )
+            )
+        );
+    }
+
+    private static int addTag(CommandSourceStack source, Collection<? extends Entity> targets, String tagName) throws CommandSyntaxException {
+        int totalTargets = targets.size();
+        if (totalTargets == 0) {
+            source.sendFailure(Component.translatable("argument.entity.notfound.entity")); // Standard NMS message
+            return 0;
+        }
+
+        AtomicInteger successCount = new AtomicInteger(0);
+        AtomicInteger completedCount = new AtomicInteger(0);
+        Plugin plugin = getMinecraftPlugin(source);
+        // Capture display name for single target case to ensure it's available in the async callback
+        final Component singleTargetDisplayName = (totalTargets == 1) ? targets.iterator().next().getDisplayName() : null;
+
+        for (Entity entity : targets) {
+            entity.getBukkitEntity().getScheduler().execute(plugin, () -> {
+                // Main task logic: add the tag
+                if (entity.addTag(tagName)) {
+                    successCount.incrementAndGet();
+                }
+            }, () -> {
+                // Completion logic: runs after the main task for each entity
+                if (completedCount.incrementAndGet() == totalTargets) {
+                    // All tasks have completed, send final summary message
+                    final int successful = successCount.get();
+                    Runnable messageSender = () -> {
+                        if (successful == 0) {
+                            source.sendFailure(Component.translatable("commands.tag.add.failed"));
+                        } else {
+                            if (totalTargets == 1 && successful == 1 && singleTargetDisplayName != null) {
+                                source.sendSuccess(() -> Component.translatable("commands.tag.add.success.single", tagName, singleTargetDisplayName), true);
+                            } else {
+                                source.sendSuccess(() -> Component.translatable("commands.tag.add.success.multiple", tagName, successful), true);
+                            }
+                        }
+                    };
+                    // Schedule the feedback message on the appropriate scheduler
+                    if (source.getEntity() != null && source.getEntity().getBukkitEntity().getScheduler() != null) {
+                        source.getEntity().getBukkitEntity().getScheduler().execute(plugin, messageSender, null, 0L);
+                    } else { // Console or other non-entity source
+                        source.getServer().getGlobalRegionScheduler().execute(plugin, messageSender);
+                    }
+                }
+            }, 0L); // Execute immediately on the entity's region thread
+        }
+        return targets.size(); // Initial return, async feedback will follow
+    }
+
+    private static int removeTag(CommandSourceStack source, Collection<? extends Entity> targets, String tagName) throws CommandSyntaxException {
+        int totalTargets = targets.size();
+        if (totalTargets == 0) {
+            source.sendFailure(Component.translatable("argument.entity.notfound.entity"));
+            return 0;
+        }
+
+        AtomicInteger successCount = new AtomicInteger(0);
+        AtomicInteger completedCount = new AtomicInteger(0);
+        Plugin plugin = getMinecraftPlugin(source);
+        final Component singleTargetDisplayNameRemove = (totalTargets == 1) ? targets.iterator().next().getDisplayName() : null;
+
+        for (Entity entity : targets) {
+            entity.getBukkitEntity().getScheduler().execute(plugin, () -> {
+                if (entity.removeTag(tagName)) {
+                    successCount.incrementAndGet();
+                }
+            }, () -> {
+                if (completedCount.incrementAndGet() == totalTargets) {
+                    final int successful = successCount.get();
+                    Runnable messageSender = () -> {
+                        if (successful == 0) {
+                            source.sendFailure(Component.translatable("commands.tag.remove.failed"));
+                        } else {
+                            if (totalTargets == 1 && successful == 1 && singleTargetDisplayNameRemove != null) {
+                                source.sendSuccess(() -> Component.translatable("commands.tag.remove.success.single", tagName, singleTargetDisplayNameRemove), true);
+                            } else {
+                                source.sendSuccess(() -> Component.translatable("commands.tag.remove.success.multiple", tagName, successful), true);
+                            }
+                        }
+                    };
+                    if (source.getEntity() != null && source.getEntity().getBukkitEntity().getScheduler() != null) {
+                        source.getEntity().getBukkitEntity().getScheduler().execute(plugin, messageSender, null, 0L);
+                    } else {
+                        source.getServer().getGlobalRegionScheduler().execute(plugin, messageSender);
+                    }
+                }
+            }, 0L);
+        }
+        return targets.size();
+    }
+
+    private static int listTags(CommandSourceStack source, Collection<? extends Entity> targets) {
+        Plugin plugin = getMinecraftPlugin(source);
+
+        if (targets.isEmpty()) {
+            // Consistent with add/remove, though list usually doesn't fail on no targets, just shows nothing.
+            // Depending on NMS vanilla behavior, this might just return 0 without error.
+            // For now, keeping it consistent with add/remove's "no entity found" handling.
+            source.sendFailure(Component.translatable("argument.entity.notfound.entity"));
+            return 0;
+        }
+
+        for (Entity entity : targets) {
+            final Component entityDisplayName = entity.getDisplayName(); // Capture for use in lambda
+            entity.getBukkitEntity().getScheduler().execute(plugin, () -> {
+                Set<String> tags = entity.getTags();
+                final Component message;
+                if (tags.isEmpty()) {
+                    message = Component.translatable("commands.tag.list.empty.single", entityDisplayName);
+                } else {
+                    message = Component.translatable("commands.tag.list.success.single", entityDisplayName, tags.size(), ComponentUtils.formatList(tags));
+                }
+
+                Runnable messageSender = () -> source.sendSuccess(() -> message, false); // false = don't broadcast to ops
+
+                if (source.getEntity() != null && source.getEntity().getBukkitEntity().getScheduler() != null) {
+                    source.getEntity().getBukkitEntity().getScheduler().execute(plugin, messageSender, null, 0L);
+                } else { // Console or other non-entity source
+                    source.getServer().getGlobalRegionScheduler().execute(plugin, messageSender);
+                }
+            }, null, 0L); // No separate completion runnable for list, message sent in main task logic
+        }
+        return targets.size(); // Returns number of entities for which listing was initiated
+    }
+}
