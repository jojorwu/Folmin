--- a/net/minecraft/commands/Commands.java
+++ b/net/minecraft/commands/Commands.java
@@ -250,9 +250,9 @@
         ScoreboardCommand.register(this.dispatcher);
         SeedCommand.register(this.dispatcher, this.environment.acl()); // Paper
         AdvancementCommands.register(this.dispatcher);
-        //TagCommand.register(this.dispatcher); // Folia - region threading - TODO later
+        TagCommand.register(this.dispatcher); // Folia - region threading - REIMPLEMENTED
         ExecuteCommand.register(this.dispatcher, this.context);
-        BossBarCommands.register(this.dispatcher);
+        BossBarCommands.register(this.dispatcher); // Paper - moved down
         ClearInventoryCommands.register(this.dispatcher, this.context);
         CloneCommands.register(this.dispatcher, this.context);
         DebugCommands.register(this.dispatcher);
--- a/net/minecraft/commands/TagCommand.java
+++ b/net/minecraft/commands/TagCommand.java
@@ -0,0 +1,144 @@
+package net.minecraft.commands;
+
+import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.arguments.StringArgumentType;
+import com.mojang.brigadier.builder.LiteralArgumentBuilder;
+import com.mojang.brigadier.builder.RequiredArgumentBuilder;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
+import java.util.Collection;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Supplier;
+import net.minecraft.commands.arguments.EntityArgument;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.ComponentUtils;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.entity.Entity;
+import org.bukkit.plugin.Plugin;
+
+public class TagCommand {
+
+    private static final SimpleCommandExceptionType ERROR_ADD_FAILED = new SimpleCommandExceptionType(Component.translatable("commands.tag.add.failed"));
+    private static final SimpleCommandExceptionType ERROR_REMOVE_FAILED = new SimpleCommandExceptionType(Component.translatable("commands.tag.remove.failed"));
+    private static final Component LIST_EMPTY_COMPONENT = Component.translatable("commands.tag.list.empty");
+
+    private static Plugin getPlugin(CommandSourceStack source) {
+        // Assuming source.getServer().getMinecraftPlugin() is available via Folia patches.
+        return source.getServer().getMinecraftPlugin();
+    }
+
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        dispatcher.register(Commands.literal("tag")
+            .requires((source) -> source.hasPermission(2))
+            .then(Commands.argument("targets", EntityArgument.entities())
+                .then(Commands.literal("add")
+                    .then(Commands.argument("name", StringArgumentType.word())
+                        .executes((context) -> addTag(
+                                context.getSource(),
+                                EntityArgument.getEntities(context, "targets"),
+                                StringArgumentType.getString(context, "name")
+                            )
+                        )
+                    )
+                )
+                .then(Commands.literal("remove")
+                    .then(Commands.argument("name", StringArgumentType.word())
+                        .executes((context) -> removeTag(
+                                context.getSource(),
+                                EntityArgument.getEntities(context, "targets"),
+                                StringArgumentType.getString(context, "name")
+                            )
+                        )
+                    )
+                )
+                .then(Commands.literal("list")
+                    .executes((context) -> listTags(
+                            context.getSource(),
+                            EntityArgument.getEntities(context, "targets")
+                        )
+                    )
+                )
+            )
+        );
+    }
+
+    private static void scheduleFeedback(CommandSourceStack source, Plugin plugin, Supplier<Component> messageSupplier, boolean success) {
+        if (source.getEntity() != null && source.getEntity().getBukkitEntity().getScheduler() != null) {
+            source.getEntity().getBukkitEntity().getScheduler().execute(plugin, () -> {
+                if (success) source.sendSuccess(messageSupplier, true); else source.sendFailure(messageSupplier.get());
+            }, null, 0L);
+        } else {
+            source.getServer().getGlobalRegionScheduler().execute(plugin, () -> {
+                 if (success) source.sendSuccess(messageSupplier, true); else source.sendFailure(messageSupplier.get());
+            });
+        }
+    }
+
+    private static int addTag(CommandSourceStack source, Collection<? extends Entity> targets, String tagName) throws CommandSyntaxException {
+        if (targets.isEmpty()) {
+            throw ERROR_ADD_FAILED.create();
+        }
+        int totalTargets = targets.size();
+        AtomicInteger successCount = new AtomicInteger(0);
+        AtomicInteger completedCount = new AtomicInteger(0);
+        final Plugin pluginContext = getPlugin(source);
+
+        for (Entity entity : targets) {
+            final Entity currentEntity = entity;
+            currentEntity.getBukkitEntity().getScheduler().execute(pluginContext,
+                () -> {
+                    if (currentEntity.addTag(tagName)) {
+                        successCount.incrementAndGet();
+                    }
+                },
+                () -> {
+                    if (completedCount.incrementAndGet() == totalTargets) {
+                        final int successful = successCount.get();
+                        if (successful == 0) {
+                            scheduleFeedback(source, pluginContext, ERROR_ADD_FAILED::getComponent, false);
+                        } else {
+                            if (totalTargets == 1) {
+                                scheduleFeedback(source, pluginContext, () -> Component.translatable("commands.tag.add.success.single", tagName, targets.iterator().next().getDisplayName()), true);
+                            } else {
+                                scheduleFeedback(source, pluginContext, () -> Component.translatable("commands.tag.add.success.multiple", tagName, successful), true);
+                            }
+                        }
+                    }
+                }, 0L);
+        }
+        return targets.size();
+    }
+
+    private static int removeTag(CommandSourceStack source, Collection<? extends Entity> targets, String tagName) throws CommandSyntaxException {
+        if (targets.isEmpty()) {
+            throw ERROR_REMOVE_FAILED.create();
+        }
+        int totalTargets = targets.size();
+        AtomicInteger successCount = new AtomicInteger(0);
+        AtomicInteger completedCount = new AtomicInteger(0);
+        final Plugin pluginContext = getPlugin(source);
+
+        for (Entity entity : targets) {
+            final Entity currentEntity = entity;
+            currentEntity.getBukkitEntity().getScheduler().execute(pluginContext,
+                () -> {
+                    if (currentEntity.removeTag(tagName)) {
+                        successCount.incrementAndGet();
+                    }
+                },
+                () -> {
+                    if (completedCount.incrementAndGet() == totalTargets) {
+                        final int successful = successCount.get();
+                        if (successful == 0) {
+                             scheduleFeedback(source, pluginContext, ERROR_REMOVE_FAILED::getComponent, false);
+                        } else {
+                            if (totalTargets == 1) {
+                                scheduleFeedback(source, pluginContext, () -> Component.translatable("commands.tag.remove.success.single", tagName, targets.iterator().next().getDisplayName()), true);
+                            } else {
+                                scheduleFeedback(source, pluginContext, () -> Component.translatable("commands.tag.remove.success.multiple", tagName, successful), true);
+                            }
+                        }
+                    }
+                }, 0L);
+        }
+        return targets.size();
+    }
+
+    private static int listTags(CommandSourceStack source, Collection<? extends Entity> targets) {
+        if (targets.isEmpty()) {
+            source.sendFailure(LIST_EMPTY_COMPONENT);
+            return 0;
+        }
+        final Plugin pluginContext = getPlugin(source);
+
+        for (Entity entity : targets) {
+            final Entity currentEntity = entity;
+            final Component entityDisplayName = currentEntity.getDisplayName();
+
+            currentEntity.getBukkitEntity().getScheduler().execute(pluginContext,
+                () -> {
+                    Set<String> tags = currentEntity.getTags();
+                    final Component message;
+                    if (tags.isEmpty()) {
+                        message = Component.translatable("commands.tag.list.empty.single", entityDisplayName);
+                    } else {
+                        message = Component.translatable("commands.tag.list.success.single", entityDisplayName, tags.size(), ComponentUtils.formatList(tags));
+                    }
+                    scheduleFeedback(source, pluginContext, () -> message, true);
+                }, null, 0L);
+        }
+        return targets.size();
+    }
+}
